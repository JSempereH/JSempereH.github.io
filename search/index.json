[{"content":"In this post I\u0026rsquo;d like to write down the steps to make the simplest Python project you could make. Mainly focused for research projects (e.g. people in academia). Therefore, there will be no pipelines (like Github Actions or Jenkins).\nVersion control Let\u0026rsquo;s say you have created your local directory: mkdir my-project. First, you need to init the version control. As of today, the most used tool is git.\n1 2 cd my-project git init You are probably using Github, Gitlab for Codeberg for hosting your repo. Let\u0026rsquo;s say you are using Github, and you have already created your repo there. Now you need to add the remote repository reference to your local Git:\n1 git remote add origin https://github.com/your-user/your-project.git This command is setting the name \u0026ldquo;origin\u0026rdquo; to that remote. You can get the URL of the remote Git repository directly on the web:\nAnother way of doing this is directly creating the Github repo and then clone it locally:\n1 git clone https://github.com/your-user/your-project.git In case it is a private repo, you will need to log in.\nYou will need to create a .gitignore file. This will tell Git which file it shouldn\u0026rsquo;t track. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 # Ignore Python cache __pycache__/ *.pyc # Ignore virtual environment .venv/ # Ignore logs *.log # Ignore IDE files .vscode/ You can indicate whole directories (e.g. .venv/) or specific files, like all the files that end with .log: *.log.\nPackage manager I will use uv for this post, since I think it\u0026rsquo;s one of the best tools. You can also use pip, poetry, pyenv, etc.\nIn case you don\u0026rsquo;t have it yet, you can install it with:\n1 curl -LsSf https://astral.sh/uv/install.sh | sh Let\u0026rsquo;s say you are already in your repo directory. Init uv with:\n1 uv init This will create the pyproject.toml, uv.lock, main.py (you will probably delete it), README.md, .python-version and a .gitignore (if you don\u0026rsquo;t have it yet).\npyproject.toml: this is a configuration file. It contains info about the project name, version, authors, dependencies, dev-dependencies (packages only needed for development), etc. For example: 1 2 3 4 5 6 7 8 [project] name = \u0026#34;my_project\u0026#34; version = \u0026#34;0.1.0\u0026#34; requires-python = \u0026#34;\u0026gt;=3.12\u0026#34; dependencies = [\u0026#34;numpy\u0026gt;=2.3.1\u0026#34;] [tool.uv] dev-dependencies = [\u0026#34;pytest\u0026#34;, \u0026#34;ruff\u0026#34;] uv.lock: this lockfile states exact versions of all dependencies, including transitive ones (those required by your direct dependencies). If you want to use a new dependency in your code (e.g. numpy) you can use:\n1 uv add numpy This will update pyproject.toml and uv.lock. If you want to install a dev-dependency (e.g. pytest), you use:\n1 uv add --dev pytest You can remove a package with uv remove. In case another collaborator is working in your project and they update the packages, you can sync your virtual environment with the dependencies listed in pyproject.toml and uv.lock with uv sync.\nIf you want to install a library locally (not changing the project\u0026rsquo;s dependencies), use uv pip. For example, if you want to create a notebook that uses your python module, but don\u0026rsquo;t want to add ipykernel to the list oof dependencies, you may use:\n1 uv pip install ipykernel As a rule of thumb, try to minimize the number of dependencies in your project. Maintaining a project means updating the dependencies and handling the possible issues. The fewer the dependencies, the better.\nClean Python code Let\u0026rsquo;s say you will write your package my-project with its __init__.py (so it is treated as a package) and some code. Your directory will look something like this:\n1 2 3 4 5 6 7 8 9 . ├── my-project │ ├── __init__.py │ └── my_code.py ├── pyproject.toml ├── README.md └── uv.lock 2 directories, 5 files (Ignoring files starting with a .)\nBefore you start writing your code, it\u0026rsquo;s better to set up some Python tools that format and correct your code.\nLinter and formatter A linter will check your code for potential errors, bad practices, styles issues and bugs. And a formatter will reformat your code automatically, so you don\u0026rsquo;t have to worry about spaces or line breaks.\nRuff can be used for both linting and formatting, you may install it as a dev-package:\n1 uv add --dev ruff Pre-commit Instead of running ruff while you are developing the code, you could run it every time you try to commit some code using pre-commit. This way, it will format the the code and warn you if changes must be made. Install it also as a dev-package:\n1 uv add --dev pre-commit Now you need to create a .pre-commit-config.yaml file in the root of your project. The following config tell pre-commit to run ruff for linting and formatting:\n1 2 3 4 5 6 repos: - repo: https://github.com/astral-sh/ruff-pre-commit rev: v0.4.8 # Use the latest tag from https://github.com/astral-sh/ruff-pre-commit/releases hooks: - id: ruff - id: ruff-format Here you can check Ruff\u0026rsquo;s default configuration.\nFinally, install the Git hook:\n1 pre-commit install Now, every time you run git commit, Ruff will check and/or format your staged files automatically. If it requeries a manual change, you won\u0026rsquo;t be able to commit until you fix the code.\nYou can ignore pre-commit using -nm instead of -m, for example:\n1 git commit -nm \u0026#34;This commit hasn\u0026#39;t run pre-commit :(\u0026#34; You may also apply the hook to all files (not just the staged ones) using:\n1 pre-commit run --all-files ","date":"2025-07-20T00:00:00Z","permalink":"https://jsempereh.github.io/posts/create-python-repo/","title":"How to create a simple Python project"}]